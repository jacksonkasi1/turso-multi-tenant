I'll enhance the code with a more scalable folder structure, use snake case for filenames, and replace Prisma with Drizzle ORM. I'll also make sure the system works with a remote Turso database and a PostgreSQL database for storing organization data.

Let's create the core files with the enhanced implementation. I'll focus on the most important files first:

// This is the project structure overview (not actual code)

/*

project/

├── src/

│   ├── config/

│   │   ├── environment.ts

│   │   └── database.ts

│   ├── db/

│   │   ├── schema/

│   │   │   └── organizations.ts

│   │   ├── migrations/

│   │   │   └── 0000_initial.sql

│   │   └── index.ts

│   ├── infra/

│   │   ├── pulumi/

│   │   │   └── turso_db.ts

│   │   └── provisioner.ts

│   ├── api/

│   │   ├── routes/

│   │   │   ├── organization_routes.ts

│   │   │   └── index.ts

│   │   ├── middleware/

│   │   │   ├── error_handler.ts

│   │   │   ├── auth.ts

│   │   │   └── rate_limiter.ts

│   │   ├── controllers/

│   │   │   └── organization_controller.ts

│   │   └── validators/

│   │       └── organization_validator.ts

│   ├── services/

│   │   └── organization_service.ts

│   ├── utils/

│   │   ├── logger.ts

│   │   ├── error.ts

│   │   └── sanitizer.ts

│   └── app.ts

├── .env.example

├── package.json

├── drizzle.config.ts

└── tsconfig.json

*/

---

import dotenv from 'dotenv';

import { z } from 'zod';

// Load environment variables

dotenv.config();

// Define environment schema with validation

const envSchema = z.object({

  // Server

  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),

  PORT: z.string().transform(val => parseInt(val, 10)).default('3000'),

  

  // Database (PostgreSQL for storing organization data)

  DATABASE_URL: z.string().url(),

  

  // Turso configuration

  TURSO_ORG: z.string(),

  TURSO_API_TOKEN: z.string(),

  TURSO_DEFAULT_REGION: z.string().default('lhr'), // Default to London region

  TURSO_ADDITIONAL_REGIONS: z.string().default(''), // Comma-separated list of additional regions

  

  // Pulumi configuration

  PULUMI_CONFIG_PASSPHRASE: z.string().optional(),

  

  // Auth & Security

  API_KEY_SECRET: z.string().optional(),

  ACCESS_TOKEN_SECRET: z.string().optional(),

  

  // Rate Limiting

  RATE_LIMIT_WINDOW_MS: z.string().transform(val => parseInt(val, 10)).default('60000'),

  RATE_LIMIT_MAX_REQUESTS: z.string().transform(val => parseInt(val, 10)).default('10'),

});

// Parse and validate environment variables

const parseEnvResult = envSchema.safeParse(process.env);

// Handle validation errors

if (!parseEnvResult.success) {

  console.error('❌ Invalid environment variables:');

  for (const error of parseEnvResult.error.errors) {

    console.error(`  - ${error.path}: ${error.message}`);

  }

  process.exit(1);

}

// Export typed environment configuration

export const env = parseEnvResult.data;

// Helper for getting Turso additional regions as array

export const getTursoRegions = (): string[] => {

  const additionalRegions = env.TURSO_ADDITIONAL_REGIONS.split(',')

    .map(region => region.trim())

    .filter(Boolean);

  

  return [env.TURSO_DEFAULT_REGION, ...additionalRegions];

};

---

import { drizzle } from 'drizzle-orm/postgres-js';

import { migrate } from 'drizzle-orm/postgres-js/migrator';

import postgres from 'postgres';

import { logger } from '../utils/logger';

import { env } from './environment';

// Create postgres connection

const queryClient = postgres(env.DATABASE_URL, { 

  max: 10, // Connection pool size

  ssl: env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,

});

// Create drizzle DB instance

export const db = drizzle(queryClient);

// Function to run migrations

export const runMigrations = async () => {

  logger.info('Running database migrations...');

  

  try {

    await migrate(db, { migrationsFolder: 'drizzle/migrations' });

    logger.info('Migrations completed successfully');

  } catch (error) {

    logger.error('Migration failed:', error);

    throw error;

  }

};

// Helper function to connect to a specific organization's Turso database

export const connectToOrgDatabase = async (dbUrl: string) => {

  // This function would connect to the organization's Turso database

  // Implementation depends on Turso client library

  // For now it's a placeholder as we'll configure this later

  

  logger.info(`Connecting to organization database at ${dbUrl}`);

  return {

    connect: async () => {

      logger.info('Connected to organization database');

      // Return connection or client

      return {};

    }

  };

};

----

import { pgTable, serial, varchar, text, timestamp, boolean } from 'drizzle-orm/pg-core';

import { createInsertSchema, createSelectSchema } from 'drizzle-zod';

import { z } from 'zod';

// Organizations table schema

export const organizations = pgTable('organizations', {

  id: serial('id').primaryKey(),

  name: varchar('name', { length: 255 }).notNull(),

  slug: varchar('slug', { length: 255 }).unique().notNull(),

  email: varchar('email', { length: 255 }).unique().notNull(),

  plan: varchar('plan', { length: 50 }).default('free').notNull(),

  status: varchar('status', { length: 50 }).default('pending').notNull(),

  

  // Database connection details

  databaseName: varchar('database_name', { length: 255 }),

  databaseUrl: text('database_url'),

  databaseHostname: varchar('database_hostname', { length: 255 }),

  databaseToken: text('database_token'), // Consider encryption for this field

  databaseRegion: varchar('database_region', { length: 50 }),

  

  // Stack management

  pulumiStackName: varchar('pulumi_stack_name', { length: 255 }),

  

  // Timestamps

  createdAt: timestamp('created_at').defaultNow().notNull(),

  updatedAt: timestamp('updated_at').defaultNow().notNull(),

  

  // For soft deletion

  isDeleted: boolean('is_deleted').default(false).notNull(),

});

// Type inference from the table schema

export type Organization = typeof organizations.$inferSelect;

export type NewOrganization = typeof organizations.$inferInsert;

// Zod schemas for validation

export const insertOrganizationSchema = createInsertSchema(organizations, {

  name: z.string().min(2).max(255),

  email: z.string().email(),

  plan: z.enum(['free', 'starter', 'business', 'enterprise']).default('free'),

  // Other fields with custom validation as needed

}).omit({ 

  id: true, 

  createdAt: true, 

  updatedAt: true, 

  isDeleted: true,

  databaseName: true,

  databaseUrl: true,

  databaseHostname: true,

  databaseToken: true,

  databaseRegion: true,

  pulumiStackName: true,

  slug: true, // We'll generate this from the name

}).partial({

  plan: true

});

// Schema for responses

export const organizationResponseSchema = createSelectSchema(organizations).omit({ 

  databaseToken: true, // Don't expose token in responses 

});

// Create separate schema for database credentials when needed internally

export const organizationWithCredentialsSchema = createSelectSchema(organizations);

// Create DB relations here if needed in the future

// export const organizationsRelations = relations(organizations, ({ many }) => ({

//   users: many(users),

// }));

---

import { db, runMigrations } from '../config/database';

import * as schema from './schema/organizations';

export {

  db,

  runMigrations,

  schema

};

---

import pino from 'pino';

import { env } from '../config/environment';

// Configure logger based on environment

const loggerConfig = {

  level: env.NODE_ENV === 'production' ? 'info' : 'debug',

  transport: env.NODE_ENV !== 'production' 

    ? {

        target: 'pino-pretty',

        options: {

          colorize: true,

          translateTime: 'SYS:standard',

          ignore: 'pid,hostname',

        },

      }

    : undefined,

  redact: {

    paths: [

      'databaseToken',

      'password',

      'token',

      'authorization',

      '*.password',

      '*.token',

      '*.authorization',

    ],

    censor: '[REDACTED]',

  },

};

// Create and export the logger instance

export const logger = pino(loggerConfig);

---

// Custom error classes for better error handling

export class AppError extends Error {

  public readonly statusCode: number;

  public readonly isOperational: boolean;

  public readonly errorCode?: string;

  constructor(

    message: string, 

    statusCode: number, 

    isOperational = true, 

    errorCode?: string

  ) {

    super(message);

    this.statusCode = statusCode;

    this.isOperational = isOperational;

    this.errorCode = errorCode;

    

    Error.captureStackTrace(this, this.constructor);

  }

}

export class BadRequestError extends AppError {

  constructor(message = 'Bad Request', errorCode?: string) {

    super(message, 400, true, errorCode);

  }

}

export class UnauthorizedError extends AppError {

  constructor(message = 'Unauthorized', errorCode?: string) {

    super(message, 401, true, errorCode);

  }

}

export class ForbiddenError extends AppError {

  constructor(message = 'Forbidden', errorCode?: string) {

    super(message, 403, true, errorCode);

  }

}

export class NotFoundError extends AppError {

  constructor(message = 'Resource not found', errorCode?: string) {

    super(message, 404, true, errorCode);

  }

}

export class ConflictError extends AppError {

  constructor(message = 'Resource already exists', errorCode?: string) {

    super(message, 409, true, errorCode);

  }

}

export class InternalServerError extends AppError {

  constructor(message = 'Internal Server Error', errorCode?: string) {

    super(message, 500, false, errorCode);

  }

}

export class ServiceUnavailableError extends AppError {

  constructor(message = 'Service temporarily unavailable', errorCode?: string) {

    super(message, 503, true, errorCode);

  }

}

---

import slugify from 'slugify';

import crypto from 'crypto';

/**

 * Sanitizes and slugifies a string for use in resource names

 * Ensures the slugified string is valid for database names and other resources

 */

export const sanitizeResourceName = (input: string, maxLength = 60): string => {

  // Convert to lowercase and replace non-alphanumeric chars with hyphens

  const sanitized = slugify(input, {

    lower: true,

    strict: true,

    trim: true,

  });

  

  // Ensure it doesn't start with a number (for compatibility with some systems)

  const startsWithNumber = /^[0-9]/.test(sanitized);

  const prefix = startsWithNumber ? 'db-' : '';

  

  // Truncate to maxLength, accounting for prefix

  const maxLengthWithPrefix = prefix ? maxLength - prefix.length : maxLength;

  const truncated = sanitized.substring(0, maxLengthWithPrefix);

  

  return ${prefix}${truncated};

};

/**

 * Creates a unique resource name by combining an organization name with a unique suffix

 * Useful when resource names must be globally unique (like database names)

 */

export const createUniqueResourceName = (

  base: string, 

  suffix: string | null = null,

  maxLength = 60

): string => {

  // Get current timestamp for uniqueness if no suffix provided

  const uniqueSuffix = suffix || Date.now().toString(36);

  

  // Sanitize the base name

  const sanitizedBase = sanitizeResourceName(base);

  

  // Calculate available length for the base name, accounting for hyphen and suffix

  const suffixLength = uniqueSuffix.length + 1; // +1 for the hyphen

  const availableLength = maxLength - suffixLength;

  

  // Truncate the base name if necessary

  const truncatedBase = sanitizedBase.substring(0, availableLength);

  

  return ${truncatedBase}-${uniqueSuffix};

};

/**

 * Generate a unique slug for an organization

 */

export const generateOrgSlug = async (name: string): Promise<string> => {

  // Basic slugification

  const baseSlug = sanitizeResourceName(name);

  

  // Add a random suffix for uniqueness

  const randomSuffix = crypto.randomBytes(3).toString('hex');

  

  return ${baseSlug}-${randomSuffix};

};

/**

 * Securely obscure sensitive information (like tokens) for logging/display

 */

export const obscureSensitiveData = (data: string): string => {

  if (!data) return '';

  

  // Keep first and last 4 chars visible, obscure the rest

  const visibleChars = 4;

  const length = data.length;

  

  if (length <= visibleChars * 2) {

    return '*'.repeat(length);

  }

  

  const firstPart = data.substring(0, visibleChars);

  const lastPart = data.substring(length - visibleChars);

  const obscuredLength = length - (visibleChars * 2);

  

  return ${firstPart}${'*'.repeat(obscuredLength)}${lastPart};

};

---

import * as pulumi from '@pulumi/pulumi';

import * as turso from '@pulumi/turso';

import { getTursoRegions } from '../../config/environment';

// Configuration interface for Turso database provisioning

export interface TursoDatabaseConfig {

  organizationName: string;

  organizationId: number;

  databaseName?: string;

  tokenExpiration?: string; // Duration string like "52w" for 52 weeks

  useSharedGroup?: boolean; // Whether to use a shared group or create a dedicated one

  sharedGroupName?: string; // Name of shared group if useSharedGroup is true

  regions?: string[]; // Override default regions if needed

}

/**

 * Creates a Pulumi program for Turso database provisioning

 * This is the actual infrastructure code that Pulumi will execute

 */

export const createTursoDatabaseProgram = (config: TursoDatabaseConfig) => {

  return async () => {

    // Get Pulumi configuration

    const pulumiConfig = new pulumi.Config();

    

    // Extract and process configuration values

    const {

      organizationName,

      organizationId,

      databaseName: configDbName,

      tokenExpiration = '52w',

      useSharedGroup = false,

      sharedGroupName,

      regions = getTursoRegions(),

    } = config;

    // Determine database name - use provided name or generate from org name

    const databaseName = configDbName || 

      org-${organizationId}-${organizationName.toLowerCase().replace(/[^a-z0-9]/g, '-').substring(0, 40)};

    

    let groupName: pulumi.Input<string>;

    

    if (useSharedGroup && sharedGroupName) {

      // Use an existing shared group

      groupName = sharedGroupName;

    } else {

      // Create a new dedicated group for this organization

      const primaryRegion = regions[0] || 'lhr';

      const orgGroup = new turso.Group(`${databaseName}-group`, {

        name: ${databaseName}-group,

        primary: primaryRegion,

        locations: regions,

      });

      

      groupName = orgGroup.name;

    }

    

    // Create the database

    const database = new turso.Database(`${databaseName}`, {

      name: databaseName,

      group: groupName,

      // Can add schema, seed data, etc. as needed

    });

    

    // Generate a database token with full access

    const dbToken = pulumi.all([database.name]).apply(([dbName]) => {

      return turso.getDatabaseToken({

        id: dbName,

        authorization: 'full-access',

        expiration: tokenExpiration,

      });

    });

    

    // Export the values that will be needed by the application

    return {

      databaseName: database.name,

      databaseHostname: database.database.apply(db => db.hostname),

      databaseToken: dbToken.jwt,

      databaseUrl: pulumi.interpolate`https://${database.database.hostname}?authorization=${dbToken.jwt}`,

      groupName: groupName,

      primaryRegion: regions[0],

    };

  };

};

---

import { eq, and } from 'drizzle-orm';

import { db } from '../db';

import { organizations, NewOrganization, Organization } from '../db/schema/organizations';

import { 

  provisionOrganizationDatabase, 

  deprovisionOrganizationDatabase, 

  ProvisionResult 

} from '../infra/provisioner';

import { generateOrgSlug } from '../utils/sanitizer';

import { logger } from '../utils/logger';

import { 

  BadRequestError, 

  ConflictError, 

  NotFoundError,

  ServiceUnavailableError

} from '../utils/error';

/**

 * Service for managing organizations and their databases

 */

export class OrganizationService {

  /**

   * Create a new organization and provision its database

   */

  async createOrganization(data: Omit<NewOrganization, 'slug'>): Promise<Organization> {

    logger.info(`Creating new organization: ${data.name}`);

    

    // Generate a slug for the organization

    const slug = await generateOrgSlug(data.name);

    

    // Check if organization with same email already exists

    const existingOrg = await db.query.organizations.findFirst({

      where: eq(organizations.email, data.email)

    });

    

    if (existingOrg) {

      throw new ConflictError('Organization with this email already exists');

    }

    

    // Start a transaction to ensure database consistency

    try {

      // First, create the organization record with 'provisioning' status

      const [org] = await db

        .insert(organizations)

        .values({

          ...data,

          slug,

          status: 'provisioning',

        })

        .returning();

      

      if (!org) {

        throw new ServiceUnavailableError('Failed to create organization record');

      }

      

      // Then, provision the Turso database

      try {

        const provisionResult = await provisionOrganizationDatabase({

          id: org.id,

          name: org.name,

          slug: org.slug

        });

        

        // Update the organization with database details

        const [updatedOrg] = await db

          .update(organizations)

          .set({

            status: 'active',

            databaseName: provisionResult.databaseName,

            databaseUrl: provisionResult.databaseUrl,

            databaseHostname: provisionResult.databaseHostname,

            databaseToken: provisionResult.databaseToken,

            databaseRegion: provisionResult.primaryRegion,

            pulumiStackName: provisionResult.stackName,

            updatedAt: new Date(),

          })

          .where(eq(organizations.id, org.id))

          .returning();

        

        return updatedOrg;

      } catch (error) {

        // If provisioning fails, update organization status to 'failed'

        await db

          .update(organizations)

          .set({

            status: 'failed',

            updatedAt: new Date(),

          })

          .where(eq(organizations.id, org.id));

        

        // Re-throw the error to be handled by the caller

        throw error;

      }

    } catch (error)

---

import { LocalWorkspace, StackSettings } from '@pulumi/pulumi/automation';
import { createTursoDatabaseProgram, TursoDatabaseConfig } from './pulumi/turso_db';
import { env } from '../config/environment';
import { logger } from '../utils/logger';
import { Organization } from '../db/schema/organizations';
import { obscureSensitiveData } from '../utils/sanitizer';
import { AppError, ServiceUnavailableError } from '../utils/error';

// Interface for the provision result
export interface ProvisionResult {
  databaseName: string;
  databaseHostname: string;
  databaseUrl: string;
  databaseToken: string;
  groupName: string;
  primaryRegion: string;
  stackName: string;
}

// Provision a new Turso database for an organization
export async function provisionOrganizationDatabase(
  organization: Pick<Organization, 'id' | 'name' | 'slug'>
): Promise<ProvisionResult> {
  logger.info(`Starting database provisioning for organization: ${organization.name} (ID: ${organization.id})`);
  
  try {
    // Create a unique stack name for this organization
    const stackName = `org-${organization.id}-${organization.slug}`;
    
    // Configure the database parameters
    const dbConfig: TursoDatabaseConfig = {
      organizationName: organization.name,
      organizationId: organization.id,
      // Using default values for other parameters
    };
    
    // Create the Pulumi program
    const pulumiProgram = createTursoDatabaseProgram(dbConfig);
    
    logger.debug(`Creating Pulumi stack: ${stackName}`);
    
    // Create a new stack for this organization
    const stack = await LocalWorkspace.createOrSelectStack({
      stackName,
      projectName: 'dynamic-turso-db',
      program: pulumiProgram,
    });
    
    // Configure the stack with Turso credentials
    await stack.setConfig('turso:organization', { value: env.TURSO_ORG });
    await stack.setConfig('turso:apiToken', { value: env.TURSO_API_TOKEN, secret: true });
    
    // Optional passphrase for stack encryption if provided
    if (env.PULUMI_CONFIG_PASSPHRASE) {
      process.env.PULUMI_CONFIG_PASSPHRASE = env.PULUMI_CONFIG_PASSPHRASE;
    }
    
    // Deploy the stack with output to logs
    logger.info(`Deploying Turso database infrastructure for ${organization.name}`);
    
    const upRes = await stack.up({ 
      onOutput: (output) => logger.debug(`[Pulumi] ${output}`),
    });
    
    // Extract and validate results
    const result = {
      databaseName: upRes.outputs.databaseName.value,
      databaseHostname: upRes.outputs.databaseHostname.value,
      databaseUrl: upRes.outputs.databaseUrl.value,
      databaseToken: upRes.outputs.databaseToken.value,
      groupName: upRes.outputs.groupName.value,
      primaryRegion: upRes.outputs.primaryRegion.value,
      stackName,
    };
    
    // Log success (obscuring sensitive data)
    logger.info(
      `Successfully provisioned database for ${organization.name}:`,
      {
        databaseName: result.databaseName,
        databaseHostname: result.databaseHostname,
        databaseToken: obscureSensitiveData(result.databaseToken),
        stackName,
      }
    );
    
    return result;
  } catch (error) {
    logger.error(`Failed to provision database for organization ${organization.id}:`, error);
    throw new ServiceUnavailableError('Failed to provision organization database');
  }
}

// Deprovision (destroy) a Turso database
export async function deprovisionOrganizationDatabase(
  stackName: string
): Promise<void> {
  logger.info(`Starting database deprovisioning for stack: ${stackName}`);
  
  try {
    // Select the existing stack
    const stack = await LocalWorkspace.selectStack({
      stackName,
      projectName: 'dynamic-turso-db',
      // We don't need a program for destruction
      program: async () => {/* Empty program */},
    });
    
    // Optional passphrase for stack encryption if provided
    if (env.PULUMI_CONFIG_PASSPHRASE) {
      process.env.PULUMI_CONFIG_PASSPHRASE = env.PULUMI_CONFIG_PASSPHRASE;
    }
    
    // Destroy the stack
    logger.info(`Destroying Turso database infrastructure for stack ${stackName}`);
    
    await stack.destroy({ 
      onOutput: (output) => logger.debug(`[Pulumi] ${output}`),
    });
    
    // Optionally remove the stack completely
    await stack.workspace.removeStack(stackName);
    
    logger.info(`Successfully deprovisioned database for stack ${stackName}`);
  } catch (error) {
    logger.error(`Failed to deprovision database for stack ${stackName}:`, error);
    throw new ServiceUnavailableError('Failed to deprovision organization database');
  }
};

---------

import { eq, and } from 'drizzle-orm';
import { db } from '../db';
import { organizations, NewOrganization, Organization } from '../db/schema/organizations';
import { 
  provisionOrganizationDatabase, 
  deprovisionOrganizationDatabase, 
  ProvisionResult 
} from '../infra/provisioner';
import { generateOrgSlug } from '../utils/sanitizer';
import { logger } from '../utils/logger';
import { 
  BadRequestError, 
  ConflictError, 
  NotFoundError,
  ServiceUnavailableError
} from '../utils/error';

/**
 * Service for managing organizations and their databases
 */
export class OrganizationService {
  /**
   * Create a new organization and provision its database
   */
  async createOrganization(data: Omit<NewOrganization, 'slug'>): Promise<Organization> {
    logger.info(`Creating new organization: ${data.name}`);
    
    // Generate a slug for the organization
    const slug = await generateOrgSlug(data.name);
    
    // Check if organization with same email already exists
    const existingOrg = await db.query.organizations.findFirst({
      where: eq(organizations.email, data.email)
    });
    
    if (existingOrg) {
      throw new ConflictError('Organization with this email already exists');
    }
    
    // Start a transaction to ensure database consistency
    try {
      // First, create the organization record with 'provisioning' status
      const [org] = await db
        .insert(organizations)
        .values({
          ...data,
          slug,
          status: 'provisioning',
        })
        .returning();
      
      if (!org) {
        throw new ServiceUnavailableError('Failed to create organization record');
      }
      
      // Then, provision the Turso database
      try {
        const provisionResult = await provisionOrganizationDatabase({
          id: org.id,
          name: org.name,
          slug: org.slug
        });
        
        // Update the organization with database details
        const [updatedOrg] = await db
          .update(organizations)
          .set({
            status: 'active',
            databaseName: provisionResult.databaseName,
            databaseUrl: provisionResult.databaseUrl,
            databaseHostname: provisionResult.databaseHostname,
            databaseToken: provisionResult.databaseToken,
            databaseRegion: provisionResult.primaryRegion,
            pulumiStackName: provisionResult.stackName,
            updatedAt: new Date(),
          })
          .where(eq(organizations.id, org.id))
          .returning();
        
        return updatedOrg;
      } catch (error) {
        // If provisioning fails, update organization status to 'failed'
        await db
          .update(organizations)
          .set({
            status: 'failed',
            updatedAt: new Date(),
          })
          .where(eq(organizations.id, org.id));
        
        // Re-throw the error to be handled by the caller
        throw error;
      }
    } catch (error) {
      logger.error('Failed to create organization:', error);
      if (error instanceof ConflictError) {
        throw error;
      }
      throw new ServiceUnavailableError('Failed to create organization');
    }
  }

  /**
   * Get organization by ID
   */
  async getOrganization(id: number): Promise<Organization> {
    const org = await db.query.organizations.findFirst({
      where: and(
        eq(organizations.id, id),
        eq(organizations.isDeleted, false)
      )
    });
    
    if (!org) {
      throw new NotFoundError(`Organization with ID ${id} not found`);
    }
    
    return org;
  }

  /**
   * Get organization by slug
   */
  async getOrganizationBySlug(slug: string): Promise<Organization> {
    const org = await db.query.organizations.findFirst({
      where: and(
        eq(organizations.slug, slug),
        eq(organizations.isDeleted, false)
      )
    });
    
    if (!org) {
      throw new NotFoundError(`Organization with slug ${slug} not found`);
    }
    
    return org;
  }

  /**
   * List all active organizations
   */
  async listOrganizations(): Promise<Organization[]> {
    return db.query.organizations.findMany({
      where: eq(organizations.isDeleted, false),
      orderBy: (organizations, { desc }) => [desc(organizations.createdAt)]
    });
  }

  /**
   * Update organization details
   */
  async updateOrganization(id: number, data: Partial<NewOrganization>): Promise<Organization> {
    // Verify organization exists
    await this.getOrganization(id);
    
    const [updatedOrg] = await db
      .update(organizations)
      .set({
        ...data,
        updatedAt: new Date()
      })
      .where(eq(organizations.id, id))
      .returning();
    
    if (!updatedOrg) {
      throw new ServiceUnavailableError('Failed to update organization');
    }
    
    return updatedOrg;
  }

  /**
   * Delete an organization and deprovision its database
   */
  async deleteOrganization(id: number, hardDelete = false): Promise<void> {
    const org = await this.getOrganization(id);
    
    // If organization has an active database, deprovision it
    if (org.status === 'active' && org.pulumiStackName) {
      try {
        await deprovisionOrganizationDatabase(org.pulumiStackName);
      } catch (error) {
        logger.error(`Failed to deprovision database for organization ${id}:`, error);
        // Continue with deletion even if deprovisioning fails
      }
    }
    
    if (hardDelete) {
      // Permanently delete the organization
      await db
        .delete(organizations)
        .where(eq(organizations.id, id));
    } else {
      // Soft delete (mark as deleted)
      await db
        .update(organizations)
        .set({
          status: 'deleted',
          isDeleted: true,
          updatedAt: new Date()
        })
        .where(eq(organizations.id, id));
    }
    
    logger.info(`Organization ${id} deleted successfully`);
  }

  /**
   * Reset organization's database (deprovision and provision a new one)
   */
  async resetOrganizationDatabase(id: number): Promise<Organization> {
    const org = await this.getOrganization(id);
    
    if (org.status !== 'active') {
      throw new BadRequestError(`Cannot reset database for organization with status: ${org.status}`);
    }
    
    if (!org.pulumiStackName) {
      throw new BadRequestError('Organization does not have an active database');
    }
    
    // Set status to resetting
    await db
      .update(organizations)
      .set({
        status: 'resetting',
        updatedAt: new Date()
      })
      .where(eq(organizations.id, id));
    
    try {
      // Deprovision the existing database
      await deprovisionOrganizationDatabase(org.pulumiStackName);
      
      // Provision a new database
      const provisionResult = await provisionOrganizationDatabase({
        id: org.id,
        name: org.name,
        slug: org.slug
      });
      
      // Update the organization with new database details
      const [updatedOrg] = await db
        .update(organizations)
        .set({
          status: 'active',
          databaseName: provisionResult.databaseName,
          databaseUrl: provisionResult.databaseUrl,
          databaseHostname: provisionResult.databaseHostname,
          databaseToken: provisionResult.databaseToken,
          databaseRegion: provisionResult.primaryRegion,
          pulumiStackName: provisionResult.stackName,
          updatedAt: new Date()
        })
        .where(eq(organizations.id, id))
        .returning();
      
      return updatedOrg;
    } catch (error) {
      // If reset fails, update organization status to 'failed'
      await db
        .update(organizations)
        .set({
          status: 'failed',
          updatedAt: new Date()
        })
        .where(eq(organizations.id, id));
      
      logger.error(`Failed to reset database for organization ${id}:`, error);
      throw new ServiceUnavailableError('Failed to reset organization database');
    }
  }
}

---

import { LocalWorkspace, StackSettings } from '@pulumi/pulumi/automation';
import { createTursoDatabaseProgram, TursoDatabaseConfig } from './pulumi/turso_db';
import { env } from '../config/environment';
import { logger } from '../utils/logger';
import { obscureSensitiveData } from '../utils/sanitizer';
import { AppError, ServiceUnavailableError } from '../utils/error';

// Interface for the provision result
export interface ProvisionResult {
  databaseName: string;
  databaseHostname: string;
  databaseUrl: string;
  databaseToken: string;
  groupName: string;
  primaryRegion: string;
  stackName: string;
}

// Provision a new Turso database for an organization
export async function provisionOrganizationDatabase(
  organization: Pick<{id: number, name: string, slug: string}, 'id' | 'name' | 'slug'>
): Promise<ProvisionResult> {
  logger.info(`Starting database provisioning for organization: ${organization.name} (ID: ${organization.id})`);
  
  try {
    // Create a unique stack name for this organization
    const stackName = `org-${organization.id}-${organization.slug}`;
    
    // Configure the database parameters
    const dbConfig: TursoDatabaseConfig = {
      organizationName: organization.name,
      organizationId: organization.id,
      // Using default values for other parameters
    };
    
    // Create the Pulumi program
    const pulumiProgram = createTursoDatabaseProgram(dbConfig);
    
    logger.debug(`Creating Pulumi stack: ${stackName}`);
    
    // Create a new stack for this organization
    const stack = await LocalWorkspace.createOrSelectStack({
      stackName,
      projectName: 'dynamic-turso-db',
      program: pulumiProgram,
    });
    
    // Configure the stack with Turso credentials
    await stack.setConfig('turso:organization', { value: env.TURSO_ORG });
    await stack.setConfig('turso:apiToken', { value: env.TURSO_API_TOKEN, secret: true });
    
    // Optional passphrase for stack encryption if provided
    if (env.PULUMI_CONFIG_PASSPHRASE) {
      process.env.PULUMI_CONFIG_PASSPHRASE = env.PULUMI_CONFIG_PASSPHRASE;
    }
    
    // Deploy the stack with output to logs
    logger.info(`Deploying Turso database infrastructure for ${organization.name}`);
    
    const upRes = await stack.up({ 
      onOutput: (output) => logger.debug(`[Pulumi] ${output}`),
    });
    
    // Extract and validate results
    const result = {
      databaseName: upRes.outputs.databaseName.value,
      databaseHostname: upRes.outputs.databaseHostname.value,
      databaseUrl: upRes.outputs.databaseUrl.value,
      databaseToken: upRes.outputs.databaseToken.value,
      groupName: upRes.outputs.groupName.value,
      primaryRegion: upRes.outputs.primaryRegion.value,
      stackName,
    };
    
    // Log success (obscuring sensitive data)
    logger.info(
      `Successfully provisioned database for ${organization.name}:`,
      {
        databaseName: result.databaseName,
        databaseHostname: result.databaseHostname,
        databaseToken: obscureSensitiveData(result.databaseToken),
        stackName,
      }
    );
    
    return result;
  } catch (error) {
    logger.error(`Failed to provision database for organization ${organization.id}:`, error);
    throw new ServiceUnavailableError('Failed to provision organization database');
  }
}

// Deprovision (destroy) a Turso database
export async function deprovisionOrganizationDatabase(
  stackName: string
): Promise<void> {
  logger.info(`Starting database deprovisioning for stack: ${stackName}`);
  
  try {
    // Select the existing stack
    const stack = await LocalWorkspace.selectStack({
      stackName,
      projectName: 'dynamic-turso-db',
      // We don't need a program for destruction
      program: async () => {/* Empty program */},
    });
    
    // Optional passphrase for stack encryption if provided
    if (env.PULUMI_CONFIG_PASSPHRASE) {
      process.env.PULUMI_CONFIG_PASSPHRASE = env.PULUMI_CONFIG_PASSPHRASE;
    }
    
    // Destroy the stack
    logger.info(`Destroying Turso database infrastructure for stack ${stackName}`);
    
    await stack.destroy({ 
      onOutput: (output) => logger.debug(`[Pulumi] ${output}`),
    });
    
    // Optionally remove the stack completely
    await stack.workspace.removeStack(stackName);
    
    logger.info(`Successfully deprovisioned database for stack ${stackName}`);
  } catch (error) {
    logger.error(`Failed to deprovision database for stack ${stackName}:`, error);
    throw new ServiceUnavailableError('Failed to deprovision organization database');
  }
}

---

import { Request, Response } from 'express';
import { OrganizationService } from '../../services/organization_service';
import { AppError } from '../../utils/error';
import { logger } from '../../utils/logger';
import { insertOrganizationSchema, organizationResponseSchema } from '../../db/schema/organizations';

const organizationService = new OrganizationService();

/**
 * Controller for organization-related API endpoints
 */
export class OrganizationController {
  /**
   * Create a new organization with its dedicated database
   */
  async createOrganization(req: Request, res: Response): Promise<void> {
    try {
      // Validate request body
      const validatedData = insertOrganizationSchema.parse(req.body);
      
      // Create the organization
      const organization = await organizationService.createOrganization(validatedData);
      
      // Return sanitized data (without sensitive credentials)
      const sanitizedResponse = organizationResponseSchema.parse(organization);
      
      res.status(201).json({
        status: 'success',
        data: sanitizedResponse
      });
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      
      logger.error('Error creating organization:', error);
      throw new AppError('Failed to create organization', 500);
    }
  }

  /**
   * Get organization by ID
   */
  async getOrganization(req: Request, res: Response): Promise<void> {
    try {
      const id = parseInt(req.params.id, 10);
      const organization = await organizationService.getOrganization(id);
      
      // Return sanitized data
      const sanitizedResponse = organizationResponseSchema.parse(organization);
      
      res.status(200).json({
        status: 'success',
        data: sanitizedResponse
      });
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      
      logger.error('Error fetching organization:', error);
      throw new AppError('Failed to fetch organization', 500);
    }
  }

  /**
   * Get organization by slug
   */
  async getOrganizationBySlug(req: Request, res: Response): Promise<void> {
    try {
      const { slug } = req.params;
      const organization = await organizationService.getOrganizationBySlug(slug);
      
      // Return sanitized data
      const sanitizedResponse = organizationResponseSchema.parse(organization);
      
      res.status(200).json({
        status: 'success',
        data: sanitizedResponse
      });
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      
      logger.error('Error fetching organization by slug:', error);
      throw new AppError('Failed to fetch organization', 500);
    }
  }

  /**
   * List all organizations
   */
  async listOrganizations(req: Request, res: Response): Promise<void> {
    try {
      const organizations = await organizationService.listOrganizations();
      
      // Sanitize each organization
      const sanitizedOrganizations = organizations.map(org => 
        organizationResponseSchema.parse(org)
      );
      
      res.status(200).json({
        status: 'success',
        results: sanitizedOrganizations.length,
        data: sanitizedOrganizations
      });
    } catch (error) {
      logger.error('Error listing organizations:', error);
      throw new AppError('Failed to list organizations', 500);
    }
  }

  /**
   * Update organization
   */
  async updateOrganization(req: Request, res: Response): Promise<void> {
    try {
      const id = parseInt(req.params.id, 10);
      
      // Validate request data
      const updateSchema = insertOrganizationSchema.partial();
      const validatedData = updateSchema.parse(req.body);
      
      const updatedOrganization = await organizationService.updateOrganization(id, validatedData);
      
      // Return sanitized data
      const sanitizedResponse = organizationResponseSchema.parse(updatedOrganization);
      
      res.status(200).json({
        status: 'success',
        data: sanitizedResponse
      });
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      
      logger.error('Error updating organization:', error);
      throw new AppError('Failed to update organization', 500);
    }
  }

  /**
   * Delete organization
   */
  async deleteOrganization(req: Request, res: Response): Promise<void> {
    try {
      const id = parseInt(req.params.id, 10);
      // Check if this is a hard delete
      const hardDelete = req.query.hardDelete === 'true';
      
      await organizationService.deleteOrganization(id, hardDelete);
      
      res.status(204).send();
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      
      logger.error('Error deleting organization:', error);
      throw new AppError('Failed to delete organization', 500);
    }
  }

  /**
   * Reset organization database
   */
  async resetOrganizationDatabase(req: Request, res: Response): Promise<void> {
    try {
      const id = parseInt(req.params.id, 10);
      
      const organization = await organizationService.resetOrganizationDatabase(id);
      
      // Return sanitized data
      const sanitizedResponse = organizationResponseSchema.parse(organization);
      
      res.status(200).json({
        status: 'success',
        data: sanitizedResponse,
        message: 'Organization database reset successfully'
      });
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      
      logger.error('Error resetting organization database:', error);
      throw new AppError('Failed to reset organization database', 500);
    }
  }
}

----

import { Router } from 'express';
import { OrganizationController } from '../controllers/organization_controller';
import { authMiddleware } from '../middleware/auth';
import { validate } from '../middleware/validation';
import { insertOrganizationSchema } from '../../db/schema/organizations';

const router = Router();
const controller = new OrganizationController();

/**
 * Organization routes
 * All routes are protected by authentication middleware
 */

// GET /organizations - List all organizations
router.get(
  '/',
  authMiddleware,
  async (req, res, next) => {
    try {
      await controller.listOrganizations(req, res);
    } catch (error) {
      next(error);
    }
  }
);

// POST /organizations - Create a new organization
router.post(
  '/',
  authMiddleware,
  validate(insertOrganizationSchema),
  async (req, res, next) => {
    try {
      await controller.createOrganization(req, res);
    } catch (error) {
      next(error);
    }
  }
);

// GET /organizations/:id - Get organization by ID
router.get(
  '/:id',
  authMiddleware,
  async (req, res, next) => {
    try {
      await controller.getOrganization(req, res);
    } catch (error) {
      next(error);
    }
  }
);

// GET /organizations/slug/:slug - Get organization by slug
router.get(
  '/slug/:slug',
  authMiddleware,
  async (req, res, next) => {
    try {
      await controller.getOrganizationBySlug(req, res);
    } catch (error) {
      next(error);
    }
  }
);

// PATCH /organizations/:id - Update organization
router.patch(
  '/:id',
  authMiddleware,
  validate(insertOrganizationSchema.partial()),
  async (req, res, next) => {
    try {
      await controller.updateOrganization(req, res);
    } catch (error) {
      next(error);
    }
  }
);

// DELETE /organizations/:id - Delete organization
router.delete(
  '/:id',
  authMiddleware,
  async (req, res, next) => {
    try {
      await controller.deleteOrganization(req, res);
    } catch (error) {
      next(error);
    }
  }
);

// POST /organizations/:id/reset-database - Reset organization database
router.post(
  '/:id/reset-database',
  authMiddleware,
  async (req, res, next) => {
    try {
      await controller.resetOrganizationDatabase(req, res);
    } catch (error) {
      next(error);
    }
  }
);

export default router;

---------

import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { BadRequestError } from '../../utils/error';

/**
 * Middleware to validate request body against a Zod schema
 * @param schema The Zod schema to validate against
 */
export const validate = (schema: z.ZodType<any, any>) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const result = schema.safeParse(req.body);
      
      if (!result.success) {
        // Format validation errors
        const formattedErrors = result.error.format();
        throw new BadRequestError('Validation failed', 'VALIDATION_ERROR');
      }
      
      // Validation passed, continue
      next();
    } catch (error) {
      next(error);
    }
  };
};

---------

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { env } from '../../config/environment';
import { UnauthorizedError, ForbiddenError } from '../../utils/error';

/**
 * Express middleware for authentication using JWT
 */
export const authMiddleware = (req: Request, res: Response, next: NextFunction) => {
  try {
    // Get the authorization header
    const authHeader = req.headers.authorization;
    
    if (!authHeader) {
      throw new UnauthorizedError('No authorization token provided');
    }
    
    // Check if it's a Bearer token
    if (!authHeader.startsWith('Bearer ')) {
      throw new UnauthorizedError('Invalid authorization format. Use Bearer token');
    }
    
    // Extract the token
    const token = authHeader.split(' ')[1];
    
    if (!token) {
      throw new UnauthorizedError('No token provided');
    }
    
    if (!env.ACCESS_TOKEN_SECRET) {
      throw new Error('ACCESS_TOKEN_SECRET is not configured');
    }
    
    // Verify the token
    try {
      const decoded = jwt.verify(token, env.ACCESS_TOKEN_SECRET);
      
      // Add the user data to the request object
      (req as any).user = decoded;
      
      next();
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError('Token expired');
      } else if (error instanceof jwt.JsonWebTokenError) {
        throw new UnauthorizedError('Invalid token');
      } else {
        throw new UnauthorizedError('Failed to authenticate');
      }
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Middleware to check if the authenticated user has the required roles
 * @param roles Array of roles that are allowed to access the resource
 */
export const roleMiddleware = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        throw new UnauthorizedError('User not authenticated');
      }
      
      if (!user.roles || !Array.isArray(user.roles)) {
        throw new ForbiddenError('User has no defined roles');
      }
      
      const hasRequiredRole = user.roles.some((role: string) => roles.includes(role));
      
      if (!hasRequiredRole) {
        throw new ForbiddenError('Insufficient permissions');
      }
      
      next();
    } catch (error) {
      next(error);
    }
  };
};

/**
 * Alternative authentication method using API key for service-to-service communication
 */
export const apiKeyAuthMiddleware = (req: Request, res: Response, next: NextFunction) => {
  try {
    const apiKey = req.headers['x-api-key'];
    
    if (!apiKey) {
      throw new UnauthorizedError('API key is required');
    }
    
    if (!env.API_KEY_SECRET || apiKey !== env.API_KEY_SECRET) {
      throw new UnauthorizedError('Invalid API key');
    }
    
    next();
  } catch (error) {
    next(error);
  }
};

----

import { Request, Response, NextFunction } from 'express';
import { ZodError } from 'zod';
import { AppError } from '../../utils/error';
import { logger } from '../../utils/logger';
import { env } from '../../config/environment';

/**
 * Global error handling middleware for Express
 */
export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Log the error details
  logger.error('Error Handler:', {
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
  });

  // Handle known application errors
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      status: 'error',
      message: err.message,
      code: err.errorCode,
      ...(env.NODE_ENV === 'development' && { stack: err.stack }),
    });
  }

  // Handle Zod validation errors
  if (err instanceof ZodError) {
    return res.status(400).json({
      status: 'error',
      message: 'Validation failed',
      errors: err.errors,
    });
  }

  // Fallback for unexpected errors
  res.status(500).json({
    status: 'error',
    message: 'Internal Server Error',
    ...(env.NODE_ENV === 'development' && { stack: err.stack }),
  });
};

----

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import { errorHandler } from './api/middleware/error_handler';
import { runMigrations } from './db';
import { logger } from './utils/logger';
import { env } from './config/environment';
import routes from './api/routes';

// Initialize express app
const app = express();

// Security middleware
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// API routes
app.use('/api', routes);

// Default route
app.get('/', (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'Multi-tenant database provisioning API',
    environment: env.NODE_ENV,
    timestamp: new Date().toISOString()
  });
});

// Error handler middleware (must be last)
app.use(errorHandler);

// Start server function
const startServer = async () => {
  try {
    // Run database migrations
    await runMigrations();
    
    // Start listening for requests
    const port = env.PORT;
    app.listen(port, () => {
      logger.info(`Server running on port ${port} in ${env.NODE_ENV} mode`);
    });
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  logger.error('UNHANDLED REJECTION:', err);
  // Give the server time to finish ongoing requests before exiting
  process.exit(1);
});

// Start server if this file is executed directly
if (require.main === module) {
  startServer();
}

// Export for testing
export default app;

--------

import rateLimit from 'express-rate-limit';
import { env } from '../../config/environment';

/**
 * Configure rate limiting middleware
 * Prevents excessive requests to the API
 */
export const rateLimiter = rateLimit({
  windowMs: env.RATE_LIMIT_WINDOW_MS, // Time window in milliseconds
  max: env.RATE_LIMIT_MAX_REQUESTS, // Max number of requests during window
  standardHeaders: true, // Return rate limit info in the RateLimit-* headers
  legacyHeaders: false, // Disable the X-RateLimit-* headers
  message: {
    status: 'error',
    message: 'Too many requests, please try again later.',
  },
  // Skip rate limiting in development mode (optional)
  skip: (req) => env.NODE_ENV === 'development',
});

----

import { Router } from 'express';
import organizationRoutes from './organization_routes';
import { rateLimiter } from '../middleware/rate_limiter';

const router = Router();

// Apply rate limiter to all API routes
router.use(rateLimiter);

// Health check endpoint
router.get('/health', (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'API is running',
    timestamp: new Date().toISOString(),
  });
});

// Mount routes
router.use('/organizations', organizationRoutes);

// Handle 404 for API routes
router.use('*', (req, res) => {
  res.status(404).json({
    status: 'error',
    message: `Cannot ${req.method} ${req.originalUrl}`,
  });
});

export default router;

------

import type { Config } from 'drizzle-kit';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config();

if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is required');
}

export default {
  schema: './src/db/schema/*',
  out: './drizzle/migrations',
  driver: 'pg', // 'pg' for PostgreSQL
  dbCredentials: {
    connectionString: process.env.DATABASE_URL,
  },
  // Customize table names (optional)
  tablesFilter: ['!_migrations'],
} satisfies Config;

-----

{
  "name": "multi-tenant-db-provisioner",
  "version": "1.0.0",
  "description": "An API for provisioning and managing multi-tenant databases with Turso",
  "main": "dist/app.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/app.js",
    "dev": "ts-node-dev --respawn --transpile-only src/app.ts",
    "lint": "eslint . --ext .ts",
    "test": "jest",
    "db:generate": "drizzle-kit generate:pg",
    "db:migrate": "ts-node src/db/migrate.ts",
    "db:push": "drizzle-kit push:pg",
    "db:studio": "drizzle-kit studio"
  },
  "keywords": [
    "multi-tenant",
    "database",
    "provisioning",
    "turso",
    "drizzle",
    "pulumi"
  ],
  "dependencies": {
    "@pulumi/pulumi": "^3.0.0",
    "@pulumi/turso": "^0.0.2",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "drizzle-orm": "^0.30.0",
    "drizzle-zod": "^0.5.0",
    "express": "^4.18.2",
    "express-rate-limit": "^7.0.0",
    "helmet": "^7.0.0",
    "jsonwebtoken": "^9.0.1",
    "pino": "^8.15.0",
    "pino-pretty": "^10.2.0",
    "postgres": "^3.4.0",
    "slugify": "^1.6.6",
    "zod": "^3.22.2"
  },
  "devDependencies": {
    "@types/compression": "^1.7.3",
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.4",
    "@types/jsonwebtoken": "^9.0.2",
    "@types/node": "^20.5.7",
    "@typescript-eslint/eslint-plugin": "^6.5.0",
    "@typescript-eslint/parser": "^6.5.0",
    "drizzle-kit": "^0.20.1",
    "eslint": "^8.48.0",
    "jest": "^29.6.4",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.2.2"
  },
  "engines": {
    "node": ">=16.0.0"
  }
}

----------

# Server Configuration
NODE_ENV=development
PORT=3000

# Database (PostgreSQL)
DATABASE_URL=postgresql://user:password@localhost:5432/multitenant

# Turso Configuration
TURSO_ORG=your_org_name
TURSO_API_TOKEN=your_api_token
TURSO_DEFAULT_REGION=lhr
TURSO_ADDITIONAL_REGIONS=sjc,fra

# Pulumi Configuration
PULUMI_CONFIG_PASSPHRASE=your_passphrase

# Auth & Security
API_KEY_SECRET=your_api_key_secret
ACCESS_TOKEN_SECRET=your_jwt_secret

# Rate Limiting
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=10


-----

-- Create organizations table
CREATE TABLE IF NOT EXISTS "organizations" (
    "id" SERIAL PRIMARY KEY,
    "name" VARCHAR(255) NOT NULL,
    "slug" VARCHAR(255) NOT NULL UNIQUE,
    "email" VARCHAR(255) NOT NULL UNIQUE,
    "plan" VARCHAR(50) NOT NULL DEFAULT 'free',
    "status" VARCHAR(50) NOT NULL DEFAULT 'pending',
    "database_name" VARCHAR(255),
    "database_url" TEXT,
    "database_hostname" VARCHAR(255),
    "database_token" TEXT,
    "database_region" VARCHAR(50),
    "pulumi_stack_name" VARCHAR(255),
    "created_at" TIMESTAMP NOT NULL DEFAULT NOW(),
    "updated_at" TIMESTAMP NOT NULL DEFAULT NOW(),
    "is_deleted" BOOLEAN NOT NULL DEFAULT FALSE
);

-- Create index for faster lookups
CREATE INDEX IF NOT EXISTS "organizations_slug_idx" ON "organizations" ("slug");
CREATE INDEX IF NOT EXISTS "organizations_status_idx" ON "organizations" ("status");
CREATE INDEX IF NOT EXISTS "organizations_is_deleted_idx" ON "organizations" ("is_deleted");

-- Add timestamp trigger for updated_at
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER update_organizations_modtime
    BEFORE UPDATE ON "organizations"
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

----------

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": false,
    "sourceMap": true,
    "removeComments": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "transpileOnly": true
  }
}

